function cleanupParent(parent) {
  if (!parent.nodes.length) {
    parent.remove();
    return;
  }

  const commentNodes = parent.nodes.filter(node => node.type === 'comment');

  if (commentNodes.length === parent.nodes.length) {
    parent.replaceWith(...commentNodes);
  }
}

function shiftNodesBeforeParent(node) {
  const parent = node.parent;
  const index = parent.index(node); // conditionally move previous siblings into a clone of the parent

  if (index) {
    const newParent = parent.cloneBefore().removeAll().append(parent.nodes.slice(0, index));
    newParent.raws.semicolon = true;
    /* nested rules end with "}" and do not have this flag set */

    cleanupParent(newParent);
  } // move the current node before the parent (and after the conditional clone)


  parent.before(node);
  parent.raws.semicolon = true;
  /* nested rules end with "}" and do not have this flag set */

  return parent;
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var dist = {exports: {}};

var processor = {exports: {}};

var parser$1 = {exports: {}};

var root$1 = {exports: {}};

var container = {exports: {}};

var node = {exports: {}};

var util = {};

var unesc = {exports: {}};

(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = unesc; // Many thanks for this post which made this migration much easier.
  // https://mathiasbynens.be/notes/css-escapes

  /**
   * 
   * @param {string} str 
   * @returns {[string, number]|undefined}
   */

  function gobbleHex(str) {
    var lower = str.toLowerCase();
    var hex = '';
    var spaceTerminated = false;

    for (var i = 0; i < 6 && lower[i] !== undefined; i++) {
      var code = lower.charCodeAt(i); // check to see if we are dealing with a valid hex char [a-f|0-9]

      var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57; // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point

      spaceTerminated = code === 32;

      if (!valid) {
        break;
      }

      hex += lower[i];
    }

    if (hex.length === 0) {
      return undefined;
    }

    var codePoint = parseInt(hex, 16);
    var isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF; // Add special case for
    // "If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point"
    // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point

    if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {
      return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
    }

    return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
  }

  var CONTAINS_ESCAPE = /\\/;

  function unesc(str) {
    var needToProcess = CONTAINS_ESCAPE.test(str);

    if (!needToProcess) {
      return str;
    }

    var ret = "";

    for (var i = 0; i < str.length; i++) {
      if (str[i] === "\\") {
        var gobbled = gobbleHex(str.slice(i + 1, i + 7));

        if (gobbled !== undefined) {
          ret += gobbled[0];
          i += gobbled[1];
          continue;
        } // Retain a pair of \\ if double escaped `\\\\`
        // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e


        if (str[i + 1] === "\\") {
          ret += "\\";
          i++;
          continue;
        } // if \\ is at the end of the string retain it
        // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb


        if (str.length === i + 1) {
          ret += str[i];
        }

        continue;
      }

      ret += str[i];
    }

    return ret;
  }

  module.exports = exports.default;
})(unesc, unesc.exports);

var getProp = {exports: {}};

(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = getProp;

  function getProp(obj) {
    for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      props[_key - 1] = arguments[_key];
    }

    while (props.length > 0) {
      var prop = props.shift();

      if (!obj[prop]) {
        return undefined;
      }

      obj = obj[prop];
    }

    return obj;
  }

  module.exports = exports.default;
})(getProp, getProp.exports);

var ensureObject = {exports: {}};

(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = ensureObject;

  function ensureObject(obj) {
    for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      props[_key - 1] = arguments[_key];
    }

    while (props.length > 0) {
      var prop = props.shift();

      if (!obj[prop]) {
        obj[prop] = {};
      }

      obj = obj[prop];
    }
  }

  module.exports = exports.default;
})(ensureObject, ensureObject.exports);

var stripComments = {exports: {}};

(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = stripComments;

  function stripComments(str) {
    var s = "";
    var commentStart = str.indexOf("/*");
    var lastEnd = 0;

    while (commentStart >= 0) {
      s = s + str.slice(lastEnd, commentStart);
      var commentEnd = str.indexOf("*/", commentStart + 2);

      if (commentEnd < 0) {
        return s;
      }

      lastEnd = commentEnd + 2;
      commentStart = str.indexOf("/*", lastEnd);
    }

    s = s + str.slice(lastEnd);
    return s;
  }

  module.exports = exports.default;
})(stripComments, stripComments.exports);

util.__esModule = true;
util.stripComments = util.ensureObject = util.getProp = util.unesc = void 0;

var _unesc = _interopRequireDefault$1(unesc.exports);

util.unesc = _unesc["default"];

var _getProp = _interopRequireDefault$1(getProp.exports);

util.getProp = _getProp["default"];

var _ensureObject = _interopRequireDefault$1(ensureObject.exports);

util.ensureObject = _ensureObject["default"];

var _stripComments = _interopRequireDefault$1(stripComments.exports);

util.stripComments = _stripComments["default"];

function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;
  var _util = util;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var cloneNode = function cloneNode(obj, parent) {
    if (typeof obj !== 'object' || obj === null) {
      return obj;
    }

    var cloned = new obj.constructor();

    for (var i in obj) {
      if (!obj.hasOwnProperty(i)) {
        continue;
      }

      var value = obj[i];
      var type = typeof value;

      if (i === 'parent' && type === 'object') {
        if (parent) {
          cloned[i] = parent;
        }
      } else if (value instanceof Array) {
        cloned[i] = value.map(function (j) {
          return cloneNode(j, cloned);
        });
      } else {
        cloned[i] = cloneNode(value, cloned);
      }
    }

    return cloned;
  };

  var Node = /*#__PURE__*/function () {
    function Node(opts) {
      if (opts === void 0) {
        opts = {};
      }

      Object.assign(this, opts);
      this.spaces = this.spaces || {};
      this.spaces.before = this.spaces.before || '';
      this.spaces.after = this.spaces.after || '';
    }

    var _proto = Node.prototype;

    _proto.remove = function remove() {
      if (this.parent) {
        this.parent.removeChild(this);
      }

      this.parent = undefined;
      return this;
    };

    _proto.replaceWith = function replaceWith() {
      if (this.parent) {
        for (var index in arguments) {
          this.parent.insertBefore(this, arguments[index]);
        }

        this.remove();
      }

      return this;
    };

    _proto.next = function next() {
      return this.parent.at(this.parent.index(this) + 1);
    };

    _proto.prev = function prev() {
      return this.parent.at(this.parent.index(this) - 1);
    };

    _proto.clone = function clone(overrides) {
      if (overrides === void 0) {
        overrides = {};
      }

      var cloned = cloneNode(this);

      for (var name in overrides) {
        cloned[name] = overrides[name];
      }

      return cloned;
    }
    /**
     * Some non-standard syntax doesn't follow normal escaping rules for css.
     * This allows non standard syntax to be appended to an existing property
     * by specifying the escaped value. By specifying the escaped value,
     * illegal characters are allowed to be directly inserted into css output.
     * @param {string} name the property to set
     * @param {any} value the unescaped value of the property
     * @param {string} valueEscaped optional. the escaped value of the property.
     */
    ;

    _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
      if (!this.raws) {
        this.raws = {};
      }

      var originalValue = this[name];
      var originalEscaped = this.raws[name];
      this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.

      if (originalEscaped || valueEscaped !== value) {
        this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
      } else {
        delete this.raws[name]; // delete any escaped value that was created by the setter.
      }
    }
    /**
     * Some non-standard syntax doesn't follow normal escaping rules for css.
     * This allows the escaped value to be specified directly, allowing illegal
     * characters to be directly inserted into css output.
     * @param {string} name the property to set
     * @param {any} value the unescaped value of the property
     * @param {string} valueEscaped the escaped value of the property.
     */
    ;

    _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
      if (!this.raws) {
        this.raws = {};
      }

      this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

      this.raws[name] = valueEscaped;
    }
    /**
     * When you want a value to passed through to CSS directly. This method
     * deletes the corresponding raw value causing the stringifier to fallback
     * to the unescaped value.
     * @param {string} name the property to set.
     * @param {any} value The value that is both escaped and unescaped.
     */
    ;

    _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
      this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

      if (this.raws) {
        delete this.raws[name];
      }
    }
    /**
     *
     * @param {number} line The number (starting with 1)
     * @param {number} column The column number (starting with 1)
     */
    ;

    _proto.isAtPosition = function isAtPosition(line, column) {
      if (this.source && this.source.start && this.source.end) {
        if (this.source.start.line > line) {
          return false;
        }

        if (this.source.end.line < line) {
          return false;
        }

        if (this.source.start.line === line && this.source.start.column > column) {
          return false;
        }

        if (this.source.end.line === line && this.source.end.column < column) {
          return false;
        }

        return true;
      }

      return undefined;
    };

    _proto.stringifyProperty = function stringifyProperty(name) {
      return this.raws && this.raws[name] || this[name];
    };

    _proto.valueToString = function valueToString() {
      return String(this.stringifyProperty("value"));
    };

    _proto.toString = function toString() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join('');
    };

    _createClass(Node, [{
      key: "rawSpaceBefore",
      get: function get() {
        var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;

        if (rawSpace === undefined) {
          rawSpace = this.spaces && this.spaces.before;
        }

        return rawSpace || "";
      },
      set: function set(raw) {
        (0, _util.ensureObject)(this, "raws", "spaces");
        this.raws.spaces.before = raw;
      }
    }, {
      key: "rawSpaceAfter",
      get: function get() {
        var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;

        if (rawSpace === undefined) {
          rawSpace = this.spaces.after;
        }

        return rawSpace || "";
      },
      set: function set(raw) {
        (0, _util.ensureObject)(this, "raws", "spaces");
        this.raws.spaces.after = raw;
      }
    }]);

    return Node;
  }();

  exports["default"] = Node;
  module.exports = exports.default;
})(node, node.exports);

var types = {};

types.__esModule = true;
types.UNIVERSAL = types.ATTRIBUTE = types.CLASS = types.COMBINATOR = types.COMMENT = types.ID = types.NESTING = types.PSEUDO = types.ROOT = types.SELECTOR = types.STRING = types.TAG = void 0;
var TAG = 'tag';
types.TAG = TAG;
var STRING = 'string';
types.STRING = STRING;
var SELECTOR = 'selector';
types.SELECTOR = SELECTOR;
var ROOT = 'root';
types.ROOT = ROOT;
var PSEUDO = 'pseudo';
types.PSEUDO = PSEUDO;
var NESTING = 'nesting';
types.NESTING = NESTING;
var ID = 'id';
types.ID = ID;
var COMMENT = 'comment';
types.COMMENT = COMMENT;
var COMBINATOR = 'combinator';
types.COMBINATOR = COMBINATOR;
var CLASS = 'class';
types.CLASS = CLASS;
var ATTRIBUTE = 'attribute';
types.ATTRIBUTE = ATTRIBUTE;
var UNIVERSAL = 'universal';
types.UNIVERSAL = UNIVERSAL;

(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _node = _interopRequireDefault(node.exports);

  var types$1 = _interopRequireWildcard(types);

  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();

    _getRequireWildcardCache = function _getRequireWildcardCache() {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return {
        "default": obj
      };
    }

    var cache = _getRequireWildcardCache();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj["default"] = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    it = o[Symbol.iterator]();
    return it.next.bind(it);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  var Container = /*#__PURE__*/function (_Node) {
    _inheritsLoose(Container, _Node);

    function Container(opts) {
      var _this;

      _this = _Node.call(this, opts) || this;

      if (!_this.nodes) {
        _this.nodes = [];
      }

      return _this;
    }

    var _proto = Container.prototype;

    _proto.append = function append(selector) {
      selector.parent = this;
      this.nodes.push(selector);
      return this;
    };

    _proto.prepend = function prepend(selector) {
      selector.parent = this;
      this.nodes.unshift(selector);
      return this;
    };

    _proto.at = function at(index) {
      return this.nodes[index];
    };

    _proto.index = function index(child) {
      if (typeof child === 'number') {
        return child;
      }

      return this.nodes.indexOf(child);
    };

    _proto.removeChild = function removeChild(child) {
      child = this.index(child);
      this.at(child).parent = undefined;
      this.nodes.splice(child, 1);
      var index;

      for (var id in this.indexes) {
        index = this.indexes[id];

        if (index >= child) {
          this.indexes[id] = index - 1;
        }
      }

      return this;
    };

    _proto.removeAll = function removeAll() {
      for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done;) {
        var node = _step.value;
        node.parent = undefined;
      }

      this.nodes = [];
      return this;
    };

    _proto.empty = function empty() {
      return this.removeAll();
    };

    _proto.insertAfter = function insertAfter(oldNode, newNode) {
      newNode.parent = this;
      var oldIndex = this.index(oldNode);
      this.nodes.splice(oldIndex + 1, 0, newNode);
      newNode.parent = this;
      var index;

      for (var id in this.indexes) {
        index = this.indexes[id];

        if (oldIndex <= index) {
          this.indexes[id] = index + 1;
        }
      }

      return this;
    };

    _proto.insertBefore = function insertBefore(oldNode, newNode) {
      newNode.parent = this;
      var oldIndex = this.index(oldNode);
      this.nodes.splice(oldIndex, 0, newNode);
      newNode.parent = this;
      var index;

      for (var id in this.indexes) {
        index = this.indexes[id];

        if (index <= oldIndex) {
          this.indexes[id] = index + 1;
        }
      }

      return this;
    };

    _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
      var found = undefined;
      this.each(function (node) {
        if (node.atPosition) {
          var foundChild = node.atPosition(line, col);

          if (foundChild) {
            found = foundChild;
            return false;
          }
        } else if (node.isAtPosition(line, col)) {
          found = node;
          return false;
        }
      });
      return found;
    }
    /**
     * Return the most specific node at the line and column number given.
     * The source location is based on the original parsed location, locations aren't
     * updated as selector nodes are mutated.
     * 
     * Note that this location is relative to the location of the first character
     * of the selector, and not the location of the selector in the overall document
     * when used in conjunction with postcss.
     *
     * If not found, returns undefined.
     * @param {number} line The line number of the node to find. (1-based index)
     * @param {number} col  The column number of the node to find. (1-based index)
     */
    ;

    _proto.atPosition = function atPosition(line, col) {
      if (this.isAtPosition(line, col)) {
        return this._findChildAtPosition(line, col) || this;
      } else {
        return undefined;
      }
    };

    _proto._inferEndPosition = function _inferEndPosition() {
      if (this.last && this.last.source && this.last.source.end) {
        this.source = this.source || {};
        this.source.end = this.source.end || {};
        Object.assign(this.source.end, this.last.source.end);
      }
    };

    _proto.each = function each(callback) {
      if (!this.lastEach) {
        this.lastEach = 0;
      }

      if (!this.indexes) {
        this.indexes = {};
      }

      this.lastEach++;
      var id = this.lastEach;
      this.indexes[id] = 0;

      if (!this.length) {
        return undefined;
      }

      var index, result;

      while (this.indexes[id] < this.length) {
        index = this.indexes[id];
        result = callback(this.at(index), index);

        if (result === false) {
          break;
        }

        this.indexes[id] += 1;
      }

      delete this.indexes[id];

      if (result === false) {
        return false;
      }
    };

    _proto.walk = function walk(callback) {
      return this.each(function (node, i) {
        var result = callback(node, i);

        if (result !== false && node.length) {
          result = node.walk(callback);
        }

        if (result === false) {
          return false;
        }
      });
    };

    _proto.walkAttributes = function walkAttributes(callback) {
      var _this2 = this;

      return this.walk(function (selector) {
        if (selector.type === types$1.ATTRIBUTE) {
          return callback.call(_this2, selector);
        }
      });
    };

    _proto.walkClasses = function walkClasses(callback) {
      var _this3 = this;

      return this.walk(function (selector) {
        if (selector.type === types$1.CLASS) {
          return callback.call(_this3, selector);
        }
      });
    };

    _proto.walkCombinators = function walkCombinators(callback) {
      var _this4 = this;

      return this.walk(function (selector) {
        if (selector.type === types$1.COMBINATOR) {
          return callback.call(_this4, selector);
        }
      });
    };

    _proto.walkComments = function walkComments(callback) {
      var _this5 = this;

      return this.walk(function (selector) {
        if (selector.type === types$1.COMMENT) {
          return callback.call(_this5, selector);
        }
      });
    };

    _proto.walkIds = function walkIds(callback) {
      var _this6 = this;

      return this.walk(function (selector) {
        if (selector.type === types$1.ID) {
          return callback.call(_this6, selector);
        }
      });
    };

    _proto.walkNesting = function walkNesting(callback) {
      var _this7 = this;

      return this.walk(function (selector) {
        if (selector.type === types$1.NESTING) {
          return callback.call(_this7, selector);
        }
      });
    };

    _proto.walkPseudos = function walkPseudos(callback) {
      var _this8 = this;

      return this.walk(function (selector) {
        if (selector.type === types$1.PSEUDO) {
          return callback.call(_this8, selector);
        }
      });
    };

    _proto.walkTags = function walkTags(callback) {
      var _this9 = this;

      return this.walk(function (selector) {
        if (selector.type === types$1.TAG) {
          return callback.call(_this9, selector);
        }
      });
    };

    _proto.walkUniversals = function walkUniversals(callback) {
      var _this10 = this;

      return this.walk(function (selector) {
        if (selector.type === types$1.UNIVERSAL) {
          return callback.call(_this10, selector);
        }
      });
    };

    _proto.split = function split(callback) {
      var _this11 = this;

      var current = [];
      return this.reduce(function (memo, node, index) {
        var split = callback.call(_this11, node);
        current.push(node);

        if (split) {
          memo.push(current);
          current = [];
        } else if (index === _this11.length - 1) {
          memo.push(current);
        }

        return memo;
      }, []);
    };

    _proto.map = function map(callback) {
      return this.nodes.map(callback);
    };

    _proto.reduce = function reduce(callback, memo) {
      return this.nodes.reduce(callback, memo);
    };

    _proto.every = function every(callback) {
      return this.nodes.every(callback);
    };

    _proto.some = function some(callback) {
      return this.nodes.some(callback);
    };

    _proto.filter = function filter(callback) {
      return this.nodes.filter(callback);
    };

    _proto.sort = function sort(callback) {
      return this.nodes.sort(callback);
    };

    _proto.toString = function toString() {
      return this.map(String).join('');
    };

    _createClass(Container, [{
      key: "first",
      get: function get() {
        return this.at(0);
      }
    }, {
      key: "last",
      get: function get() {
        return this.at(this.length - 1);
      }
    }, {
      key: "length",
      get: function get() {
        return this.nodes.length;
      }
    }]);

    return Container;
  }(_node["default"]);

  exports["default"] = Container;
  module.exports = exports.default;
})(container, container.exports);

(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _container = _interopRequireDefault(container.exports);

  var _types = types;

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  var Root = /*#__PURE__*/function (_Container) {
    _inheritsLoose(Root, _Container);

    function Root(opts) {
      var _this;

      _this = _Container.call(this, opts) || this;
      _this.type = _types.ROOT;
      return _this;
    }

    var _proto = Root.prototype;

    _proto.toString = function toString() {
      var str = this.reduce(function (memo, selector) {
        memo.push(String(selector));
        return memo;
      }, []).join(',');
      return this.trailingComma ? str + ',' : str;
    };

    _proto.error = function error(message, options) {
      if (this._error) {
        return this._error(message, options);
      } else {
        return new Error(message);
      }
    };

    _createClass(Root, [{
      key: "errorGenerator",
      set: function set(handler) {
        this._error = handler;
      }
    }]);

    return Root;
  }(_container["default"]);

  exports["default"] = Root;
  module.exports = exports.default;
})(root$1, root$1.exports);

var selector$1 = {exports: {}};

(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _container = _interopRequireDefault(container.exports);

  var _types = types;

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  var Selector = /*#__PURE__*/function (_Container) {
    _inheritsLoose(Selector, _Container);

    function Selector(opts) {
      var _this;

      _this = _Container.call(this, opts) || this;
      _this.type = _types.SELECTOR;
      return _this;
    }

    return Selector;
  }(_container["default"]);

  exports["default"] = Selector;
  module.exports = exports.default;
})(selector$1, selector$1.exports);

var className$1 = {exports: {}};

/*! https://mths.be/cssesc v3.0.0 by @mathias */

var object = {};
var hasOwnProperty = object.hasOwnProperty;

var merge = function merge(options, defaults) {
  if (!options) {
    return defaults;
  }

  var result = {};

  for (var key in defaults) {
    // `if (defaults.hasOwnProperty(key) { … }` is not needed here, since
    // only recognized option names are used.
    result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
  }

  return result;
};

var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g; // https://mathiasbynens.be/notes/css-escapes#css

var cssesc = function cssesc(string, options) {
  options = merge(options, cssesc.options);

  if (options.quotes != 'single' && options.quotes != 'double') {
    options.quotes = 'single';
  }

  var quote = options.quotes == 'double' ? '"' : '\'';
  var isIdentifier = options.isIdentifier;
  var firstChar = string.charAt(0);
  var output = '';
  var counter = 0;
  var length = string.length;

  while (counter < length) {
    var character = string.charAt(counter++);
    var codePoint = character.charCodeAt();
    var value = void 0; // If it’s not a printable ASCII character…

    if (codePoint < 0x20 || codePoint > 0x7E) {
      if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
        // It’s a high surrogate, and there is a next character.
        var extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // next character is low surrogate
          codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
        } else {
          // It’s an unmatched surrogate; only append this code unit, in case
          // the next code unit is the high surrogate of a surrogate pair.
          counter--;
        }
      }

      value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
    } else {
      if (options.escapeEverything) {
        if (regexAnySingleEscape.test(character)) {
          value = '\\' + character;
        } else {
          value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
        }
      } else if (/[\t\n\f\r\x0B]/.test(character)) {
        value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
      } else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
        value = '\\' + character;
      } else {
        value = character;
      }
    }

    output += value;
  }

  if (isIdentifier) {
    if (/^-[-\d]/.test(output)) {
      output = '\\-' + output.slice(1);
    } else if (/\d/.test(firstChar)) {
      output = '\\3' + firstChar + ' ' + output.slice(1);
    }
  } // Remove spaces after `\HEX` escapes that are not followed by a hex digit,
  // since they’re redundant. Note that this is only possible if the escape
  // sequence isn’t preceded by an odd number of backslashes.


  output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {
    if ($1 && $1.length % 2) {
      // It’s not safe to remove the space, so don’t.
      return $0;
    } // Strip the space.


    return ($1 || '') + $2;
  });

  if (!isIdentifier && options.wrap) {
    return quote + output + quote;
  }

  return output;
}; // Expose default options (so they can be overridden globally).


cssesc.options = {
  'escapeEverything': false,
  'isIdentifier': false,
  'quotes': 'single',
  'wrap': false
};
cssesc.version = '3.0.0';
var cssesc_1 = cssesc;

(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _cssesc = _interopRequireDefault(cssesc_1);

  var _util = util;

  var _node = _interopRequireDefault(node.exports);

  var _types = types;

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  var ClassName = /*#__PURE__*/function (_Node) {
    _inheritsLoose(ClassName, _Node);

    function ClassName(opts) {
      var _this;

      _this = _Node.call(this, opts) || this;
      _this.type = _types.CLASS;
      _this._constructed = true;
      return _this;
    }

    var _proto = ClassName.prototype;

    _proto.valueToString = function valueToString() {
      return '.' + _Node.prototype.valueToString.call(this);
    };

    _createClass(ClassName, [{
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(v) {
        if (this._constructed) {
          var escaped = (0, _cssesc["default"])(v, {
            isIdentifier: true
          });

          if (escaped !== v) {
            (0, _util.ensureObject)(this, "raws");
            this.raws.value = escaped;
          } else if (this.raws) {
            delete this.raws.value;
          }
        }

        this._value = v;
      }
    }]);

    return ClassName;
  }(_node["default"]);

  exports["default"] = ClassName;
  module.exports = exports.default;
})(className$1, className$1.exports);

var comment$2 = {exports: {}};

(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _node = _interopRequireDefault(node.exports);

  var _types = types;

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  var Comment = /*#__PURE__*/function (_Node) {
    _inheritsLoose(Comment, _Node);

    function Comment(opts) {
      var _this;

      _this = _Node.call(this, opts) || this;
      _this.type = _types.COMMENT;
      return _this;
    }

    return Comment;
  }(_node["default"]);

  exports["default"] = Comment;
  module.exports = exports.default;
})(comment$2, comment$2.exports);

var id$1 = {exports: {}};

(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _node = _interopRequireDefault(node.exports);

  var _types = types;

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  var ID = /*#__PURE__*/function (_Node) {
    _inheritsLoose(ID, _Node);

    function ID(opts) {
      var _this;

      _this = _Node.call(this, opts) || this;
      _this.type = _types.ID;
      return _this;
    }

    var _proto = ID.prototype;

    _proto.valueToString = function valueToString() {
      return '#' + _Node.prototype.valueToString.call(this);
    };

    return ID;
  }(_node["default"]);

  exports["default"] = ID;
  module.exports = exports.default;
})(id$1, id$1.exports);

var tag$1 = {exports: {}};

var namespace = {exports: {}};

(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _cssesc = _interopRequireDefault(cssesc_1);

  var _util = util;

  var _node = _interopRequireDefault(node.exports);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  var Namespace = /*#__PURE__*/function (_Node) {
    _inheritsLoose(Namespace, _Node);

    function Namespace() {
      return _Node.apply(this, arguments) || this;
    }

    var _proto = Namespace.prototype;

    _proto.qualifiedName = function qualifiedName(value) {
      if (this.namespace) {
        return this.namespaceString + "|" + value;
      } else {
        return value;
      }
    };

    _proto.valueToString = function valueToString() {
      return this.qualifiedName(_Node.prototype.valueToString.call(this));
    };

    _createClass(Namespace, [{
      key: "namespace",
      get: function get() {
        return this._namespace;
      },
      set: function set(namespace) {
        if (namespace === true || namespace === "*" || namespace === "&") {
          this._namespace = namespace;

          if (this.raws) {
            delete this.raws.namespace;
          }

          return;
        }

        var escaped = (0, _cssesc["default"])(namespace, {
          isIdentifier: true
        });
        this._namespace = namespace;

        if (escaped !== namespace) {
          (0, _util.ensureObject)(this, "raws");
          this.raws.namespace = escaped;
        } else if (this.raws) {
          delete this.raws.namespace;
        }
      }
    }, {
      key: "ns",
      get: function get() {
        return this._namespace;
      },
      set: function set(namespace) {
        this.namespace = namespace;
      }
    }, {
      key: "namespaceString",
      get: function get() {
        if (this.namespace) {
          var ns = this.stringifyProperty("namespace");

          if (ns === true) {
            return '';
          } else {
            return ns;
          }
        } else {
          return '';
        }
      }
    }]);

    return Namespace;
  }(_node["default"]);

  exports["default"] = Namespace;
  module.exports = exports.default;
})(namespace, namespace.exports);

(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _namespace = _interopRequireDefault(namespace.exports);

  var _types = types;

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  var Tag = /*#__PURE__*/function (_Namespace) {
    _inheritsLoose(Tag, _Namespace);

    function Tag(opts) {
      var _this;

      _this = _Namespace.call(this, opts) || this;
      _this.type = _types.TAG;
      return _this;
    }

    return Tag;
  }(_namespace["default"]);

  exports["default"] = Tag;
  module.exports = exports.default;
})(tag$1, tag$1.exports);

var string$1 = {exports: {}};

(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _node = _interopRequireDefault(node.exports);

  var _types = types;

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  var String = /*#__PURE__*/function (_Node) {
    _inheritsLoose(String, _Node);

    function String(opts) {
      var _this;

      _this = _Node.call(this, opts) || this;
      _this.type = _types.STRING;
      return _this;
    }

    return String;
  }(_node["default"]);

  exports["default"] = String;
  module.exports = exports.default;
})(string$1, string$1.exports);

var pseudo$1 = {exports: {}};

(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _container = _interopRequireDefault(container.exports);

  var _types = types;

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  var Pseudo = /*#__PURE__*/function (_Container) {
    _inheritsLoose(Pseudo, _Container);

    function Pseudo(opts) {
      var _this;

      _this = _Container.call(this, opts) || this;
      _this.type = _types.PSEUDO;
      return _this;
    }

    var _proto = Pseudo.prototype;

    _proto.toString = function toString() {
      var params = this.length ? '(' + this.map(String).join(',') + ')' : '';
      return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join('');
    };

    return Pseudo;
  }(_container["default"]);

  exports["default"] = Pseudo;
  module.exports = exports.default;
})(pseudo$1, pseudo$1.exports);

var attribute$1 = {};

/**
 * Module exports.
 */

var browser = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */


function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!commonjsGlobal.localStorage) return false;
  } catch (_) {
    return false;
  }

  var val = commonjsGlobal.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

(function (exports) {

  exports.__esModule = true;
  exports.unescapeValue = unescapeValue;
  exports["default"] = void 0;

  var _cssesc = _interopRequireDefault(cssesc_1);

  var _unesc = _interopRequireDefault(unesc.exports);

  var _namespace = _interopRequireDefault(namespace.exports);

  var _types = types;

  var _CSSESC_QUOTE_OPTIONS;

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  var deprecate = browser;
  var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
  var warnOfDeprecatedValueAssignment = deprecate(function () {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. " + "Call attribute.setValue() instead.");
  var warnOfDeprecatedQuotedAssignment = deprecate(function () {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
  var warnOfDeprecatedConstructor = deprecate(function () {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");

  function unescapeValue(value) {
    var deprecatedUsage = false;
    var quoteMark = null;
    var unescaped = value;
    var m = unescaped.match(WRAPPED_IN_QUOTES);

    if (m) {
      quoteMark = m[1];
      unescaped = m[2];
    }

    unescaped = (0, _unesc["default"])(unescaped);

    if (unescaped !== value) {
      deprecatedUsage = true;
    }

    return {
      deprecatedUsage: deprecatedUsage,
      unescaped: unescaped,
      quoteMark: quoteMark
    };
  }

  function handleDeprecatedContructorOpts(opts) {
    if (opts.quoteMark !== undefined) {
      return opts;
    }

    if (opts.value === undefined) {
      return opts;
    }

    warnOfDeprecatedConstructor();

    var _unescapeValue = unescapeValue(opts.value),
        quoteMark = _unescapeValue.quoteMark,
        unescaped = _unescapeValue.unescaped;

    if (!opts.raws) {
      opts.raws = {};
    }

    if (opts.raws.value === undefined) {
      opts.raws.value = opts.value;
    }

    opts.value = unescaped;
    opts.quoteMark = quoteMark;
    return opts;
  }

  var Attribute = /*#__PURE__*/function (_Namespace) {
    _inheritsLoose(Attribute, _Namespace);

    function Attribute(opts) {
      var _this;

      if (opts === void 0) {
        opts = {};
      }

      _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
      _this.type = _types.ATTRIBUTE;
      _this.raws = _this.raws || {};
      Object.defineProperty(_this.raws, 'unquoted', {
        get: deprecate(function () {
          return _this.value;
        }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
        set: deprecate(function () {
          return _this.value;
        }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
      });
      _this._constructed = true;
      return _this;
    }
    /**
     * Returns the Attribute's value quoted such that it would be legal to use
     * in the value of a css file. The original value's quotation setting
     * used for stringification is left unchanged. See `setValue(value, options)`
     * if you want to control the quote settings of a new value for the attribute.
     *
     * You can also change the quotation used for the current value by setting quoteMark.
     *
     * Options:
     *   * quoteMark {'"' | "'" | null} - Use this value to quote the value. If this
     *     option is not set, the original value for quoteMark will be used. If
     *     indeterminate, a double quote is used. The legal values are:
     *     * `null` - the value will be unquoted and characters will be escaped as necessary.
     *     * `'` - the value will be quoted with a single quote and single quotes are escaped.
     *     * `"` - the value will be quoted with a double quote and double quotes are escaped.
     *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark
     *     over the quoteMark option value.
     *   * smart {boolean} - if true, will select a quote mark based on the value
     *     and the other options specified here. See the `smartQuoteMark()`
     *     method.
     **/


    var _proto = Attribute.prototype;

    _proto.getQuotedValue = function getQuotedValue(options) {
      if (options === void 0) {
        options = {};
      }

      var quoteMark = this._determineQuoteMark(options);

      var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
      var escaped = (0, _cssesc["default"])(this._value, cssescopts);
      return escaped;
    };

    _proto._determineQuoteMark = function _determineQuoteMark(options) {
      return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
    }
    /**
     * Set the unescaped value with the specified quotation options. The value
     * provided must not include any wrapping quote marks -- those quotes will
     * be interpreted as part of the value and escaped accordingly.
     */
    ;

    _proto.setValue = function setValue(value, options) {
      if (options === void 0) {
        options = {};
      }

      this._value = value;
      this._quoteMark = this._determineQuoteMark(options);

      this._syncRawValue();
    }
    /**
     * Intelligently select a quoteMark value based on the value's contents. If
     * the value is a legal CSS ident, it will not be quoted. Otherwise a quote
     * mark will be picked that minimizes the number of escapes.
     *
     * If there's no clear winner, the quote mark from these options is used,
     * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is
     * true). If the quoteMark is unspecified, a double quote is used.
     *
     * @param options This takes the quoteMark and preferCurrentQuoteMark options
     * from the quoteValue method.
     */
    ;

    _proto.smartQuoteMark = function smartQuoteMark(options) {
      var v = this.value;
      var numSingleQuotes = v.replace(/[^']/g, '').length;
      var numDoubleQuotes = v.replace(/[^"]/g, '').length;

      if (numSingleQuotes + numDoubleQuotes === 0) {
        var escaped = (0, _cssesc["default"])(v, {
          isIdentifier: true
        });

        if (escaped === v) {
          return Attribute.NO_QUOTE;
        } else {
          var pref = this.preferredQuoteMark(options);

          if (pref === Attribute.NO_QUOTE) {
            // pick a quote mark that isn't none and see if it's smaller
            var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;
            var opts = CSSESC_QUOTE_OPTIONS[quote];
            var quoteValue = (0, _cssesc["default"])(v, opts);

            if (quoteValue.length < escaped.length) {
              return quote;
            }
          }

          return pref;
        }
      } else if (numDoubleQuotes === numSingleQuotes) {
        return this.preferredQuoteMark(options);
      } else if (numDoubleQuotes < numSingleQuotes) {
        return Attribute.DOUBLE_QUOTE;
      } else {
        return Attribute.SINGLE_QUOTE;
      }
    }
    /**
     * Selects the preferred quote mark based on the options and the current quote mark value.
     * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`
     * instead.
     */
    ;

    _proto.preferredQuoteMark = function preferredQuoteMark(options) {
      var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;

      if (quoteMark === undefined) {
        quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
      }

      if (quoteMark === undefined) {
        quoteMark = Attribute.DOUBLE_QUOTE;
      }

      return quoteMark;
    };

    _proto._syncRawValue = function _syncRawValue() {
      var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);

      if (rawValue === this._value) {
        if (this.raws) {
          delete this.raws.value;
        }
      } else {
        this.raws.value = rawValue;
      }
    };

    _proto._handleEscapes = function _handleEscapes(prop, value) {
      if (this._constructed) {
        var escaped = (0, _cssesc["default"])(value, {
          isIdentifier: true
        });

        if (escaped !== value) {
          this.raws[prop] = escaped;
        } else {
          delete this.raws[prop];
        }
      }
    };

    _proto._spacesFor = function _spacesFor(name) {
      var attrSpaces = {
        before: '',
        after: ''
      };
      var spaces = this.spaces[name] || {};
      var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
      return Object.assign(attrSpaces, spaces, rawSpaces);
    };

    _proto._stringFor = function _stringFor(name, spaceName, concat) {
      if (spaceName === void 0) {
        spaceName = name;
      }

      if (concat === void 0) {
        concat = defaultAttrConcat;
      }

      var attrSpaces = this._spacesFor(spaceName);

      return concat(this.stringifyProperty(name), attrSpaces);
    }
    /**
     * returns the offset of the attribute part specified relative to the
     * start of the node of the output string.
     *
     * * "ns" - alias for "namespace"
     * * "namespace" - the namespace if it exists.
     * * "attribute" - the attribute name
     * * "attributeNS" - the start of the attribute or its namespace
     * * "operator" - the match operator of the attribute
     * * "value" - The value (string or identifier)
     * * "insensitive" - the case insensitivity flag;
     * @param part One of the possible values inside an attribute.
     * @returns -1 if the name is invalid or the value doesn't exist in this attribute.
     */
    ;

    _proto.offsetOf = function offsetOf(name) {
      var count = 1;

      var attributeSpaces = this._spacesFor("attribute");

      count += attributeSpaces.before.length;

      if (name === "namespace" || name === "ns") {
        return this.namespace ? count : -1;
      }

      if (name === "attributeNS") {
        return count;
      }

      count += this.namespaceString.length;

      if (this.namespace) {
        count += 1;
      }

      if (name === "attribute") {
        return count;
      }

      count += this.stringifyProperty("attribute").length;
      count += attributeSpaces.after.length;

      var operatorSpaces = this._spacesFor("operator");

      count += operatorSpaces.before.length;
      var operator = this.stringifyProperty("operator");

      if (name === "operator") {
        return operator ? count : -1;
      }

      count += operator.length;
      count += operatorSpaces.after.length;

      var valueSpaces = this._spacesFor("value");

      count += valueSpaces.before.length;
      var value = this.stringifyProperty("value");

      if (name === "value") {
        return value ? count : -1;
      }

      count += value.length;
      count += valueSpaces.after.length;

      var insensitiveSpaces = this._spacesFor("insensitive");

      count += insensitiveSpaces.before.length;

      if (name === "insensitive") {
        return this.insensitive ? count : -1;
      }

      return -1;
    };

    _proto.toString = function toString() {
      var _this2 = this;

      var selector = [this.rawSpaceBefore, '['];
      selector.push(this._stringFor('qualifiedAttribute', 'attribute'));

      if (this.operator && (this.value || this.value === '')) {
        selector.push(this._stringFor('operator'));
        selector.push(this._stringFor('value'));
        selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {
          if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
            attrSpaces.before = " ";
          }

          return defaultAttrConcat(attrValue, attrSpaces);
        }));
      }

      selector.push(']');
      selector.push(this.rawSpaceAfter);
      return selector.join('');
    };

    _createClass(Attribute, [{
      key: "quoted",
      get: function get() {
        var qm = this.quoteMark;
        return qm === "'" || qm === '"';
      },
      set: function set(value) {
        warnOfDeprecatedQuotedAssignment();
      }
      /**
       * returns a single (`'`) or double (`"`) quote character if the value is quoted.
       * returns `null` if the value is not quoted.
       * returns `undefined` if the quotation state is unknown (this can happen when
       * the attribute is constructed without specifying a quote mark.)
       */

    }, {
      key: "quoteMark",
      get: function get() {
        return this._quoteMark;
      }
      /**
       * Set the quote mark to be used by this attribute's value.
       * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute
       * value is updated accordingly.
       *
       * @param {"'" | '"' | null} quoteMark The quote mark or `null` if the value should be unquoted.
       */
      ,
      set: function set(quoteMark) {
        if (!this._constructed) {
          this._quoteMark = quoteMark;
          return;
        }

        if (this._quoteMark !== quoteMark) {
          this._quoteMark = quoteMark;

          this._syncRawValue();
        }
      }
    }, {
      key: "qualifiedAttribute",
      get: function get() {
        return this.qualifiedName(this.raws.attribute || this.attribute);
      }
    }, {
      key: "insensitiveFlag",
      get: function get() {
        return this.insensitive ? 'i' : '';
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      }
      /**
       * Before 3.0, the value had to be set to an escaped value including any wrapped
       * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
       * is unescaped during parsing and any quote marks are removed.
       *
       * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
       * a deprecation warning is raised when the new value contains any characters that would
       * require escaping (including if it contains wrapped quotes).
       *
       * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
       * how the new value is quoted.
       */
      ,
      set: function set(v) {
        if (this._constructed) {
          var _unescapeValue2 = unescapeValue(v),
              deprecatedUsage = _unescapeValue2.deprecatedUsage,
              unescaped = _unescapeValue2.unescaped,
              quoteMark = _unescapeValue2.quoteMark;

          if (deprecatedUsage) {
            warnOfDeprecatedValueAssignment();
          }

          if (unescaped === this._value && quoteMark === this._quoteMark) {
            return;
          }

          this